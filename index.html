<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3D Anamorphic - Stabilized & Matte</title>
    <style>
        :root { --accent-color: #00fff2; --bg-color: #111; --ui-bg: rgba(0,0,0,0.85); }
        body { margin: 0; background: var(--bg-color); overflow: hidden; font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; }
        
        /* Layout Containers */
        #fixed-frame { position: absolute; width: 500px; height: 650px; background: #ffffff; box-shadow: 0 0 50px rgba(0,0,0,0.5); z-index: 1; pointer-events: none; }
        #three-canvas-container { position: absolute; width: 100vw; height: 100vh; z-index: 2; pointer-events: none; }
        
        /* UI Panel */
        #ui-panel {
            position: fixed; top: 10px; left: 10px; z-index: 100;
            background: var(--ui-bg); padding: 15px; border-radius: 8px;
            color: white; width: 260px; font-size: 0.8em; border: 1px solid #444;
            max-height: 90vh; overflow-y: auto;
        }
        .control-group { margin-bottom: 8px; }
        .control-group label { display: block; margin-bottom: 2px; color: var(--accent-color); }
        input[type="range"] { width: 100%; cursor: pointer; }
        .val { float: right; color: #fff; }
        hr { border: 0; border-top: 1px solid #444; margin: 10px 0; }
        
        /* Webcam Preview */
        #video-container { position: fixed; bottom: 10px; right: 10px; width: 130px; height: 100px; border: 1px solid #444; transform: scaleX(-1); border-radius: 4px; overflow: hidden; z-index: 10; }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

<div id="fixed-frame"></div>
<div id="three-canvas-container"></div>

<div id="ui-panel">
    <div id="status" style="margin-bottom: 10px; color: yellow;">カメラ起動中...</div>
    <input type="file" id="file-input" accept=".fbx" style="margin-bottom:10px; width:100%;">
    
    <div class="control-group"><label>Perspective <span class="val" data-bind="perspective"></span></label><input type="range" id="p-perspective" min="0" max="1500"></div>
    <div class="control-group"><label>Distortion <span class="val" data-bind="distortion"></span></label><input type="range" id="p-distortion" min="0" max="1500"></div>
    <hr>
    <div class="control-group"><label>Shadow Shift X <span class="val" data-bind="sshiftX"></span></label><input type="range" id="p-sshiftX" min="0" max="800"></div>
    <div class="control-group"><label>Shadow Shift Y <span class="val" data-bind="sshiftY"></span></label><input type="range" id="p-sshiftY" min="0" max="800"></div>
    <div class="control-group"><label>Shadow Dir X <span class="val" data-bind="dirX"></span></label><input type="range" id="p-dirX" min="-1000" max="1000"></div>
    <div class="control-group"><label>Shadow Dir Y <span class="val" data-bind="dirY"></span></label><input type="range" id="p-dirY" min="0" max="1000"></div>
    <hr>
    <div class="control-group"><label>Pos X <span class="val" data-bind="posX"></span></label><input type="range" id="p-posX" min="-500" max="500"></div>
    <div class="control-group"><label>Pos Y <span class="val" data-bind="posY"></span></label><input type="range" id="p-posY" min="-800" max="200"></div>
    <div class="control-group"><label>Model Scale <span class="val" data-bind="scale"></span></label><input type="range" id="p-scale" min="50" max="800"></div>
</div>

<div id="video-container"><video id="webcam" autoplay playsinline></video></div>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js";

    // ==========================================
    // 1. Config & State Management
    // ==========================================
    const DEFAULT_PARAMS = { 
        perspective: 380, distortion: 70, 
        sshiftX: 90, sshiftY: 0, 
        dirX: 170, dirY: 160,
        posX: 0, posY: -160, 
        neckRot: 1.2, scale: 365 
    };

    const state = {
        params: { ...DEFAULT_PARAMS },
        listeners: [],
        set(key, value) {
            this.params[key] = value;
            this.notify(key, value);
        },
        get(key) { return this.params[key]; },
        subscribe(callback) { this.listeners.push(callback); },
        notify(key, value) { this.listeners.forEach(cb => cb(key, value)); }
    };

    // ==========================================
    // 2. Scene Manager
    // ==========================================
    class SceneManager {
        constructor(containerId) {
            this.width = window.innerWidth;
            this.height = window.innerHeight;
            this.container = document.getElementById(containerId);

            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            this.renderer.setSize(this.width, this.height);
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            // ガンマ補正を有効にして、色味を少し柔らかくする
            this.renderer.outputEncoding = THREE.sRGBEncoding;
            this.container.appendChild(this.renderer.domElement);

            this.charScene = new THREE.Scene();
            this.charCamera = new THREE.PerspectiveCamera(45, this.width / this.height, 1, 5000);
            this.renderTarget = new THREE.WebGLRenderTarget(this.width, this.height, { antialias: true, alpha: true });

            this.sunLight = new THREE.DirectionalLight(0xffffff, 1.8);
            this.setupLights();
            // 環境光を少し強めにして影を柔らかく
            this.charScene.add(new THREE.AmbientLight(0xffffff, 0.6));

            this.shadowPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(3000, 3000),
                new THREE.ShadowMaterial({ opacity: 0.4 }) // 影の濃さを少し下げる
            );
            this.shadowPlane.receiveShadow = true;
            this.shadowPlane.position.z = -100;
            this.charScene.add(this.shadowPlane);

            this.postScene = new THREE.Scene();
            this.postCamera = new THREE.OrthographicCamera(-this.width/2, this.width/2, this.height/2, -this.height/2, 0.1, 1000);
            this.postCamera.position.z = 10;

            this.screenPlaneGeometry = new THREE.PlaneGeometry(this.width, this.height, 1, 1);
            const screenMaterial = new THREE.MeshBasicMaterial({ map: this.renderTarget.texture, transparent: true });
            this.postScene.add(new THREE.Mesh(this.screenPlaneGeometry, screenMaterial));

            window.addEventListener('resize', () => this.onWindowResize());
        }

        setupLights() {
            this.sunLight.castShadow = true;
            this.sunLight.shadow.mapSize.set(2048, 2048);
            const d = 600;
            this.sunLight.shadow.camera.left = -d; this.sunLight.shadow.camera.right = d;
            this.sunLight.shadow.camera.top = d; this.sunLight.shadow.camera.bottom = -d;
            this.sunLight.shadow.camera.near = 1; this.sunLight.shadow.camera.far = 3000;
            this.sunLight.shadow.bias = -0.0002;
            this.charScene.add(this.sunLight);
        }

        updateCameraAndShadows(noseX, noseY) {
            const p = state.params;
            const camX = (noseX - 0.5) * -p.perspective;
            const camY = (noseY - 0.5) * -(p.perspective * 0.6);
            this.charCamera.position.set(camX, camY, 800);
            this.charCamera.lookAt(0, 0, 0);

            this.shadowPlane.position.set(camX, camY, -100);
            this.shadowPlane.lookAt(camX, camY, 2000);

            this.sunLight.position.set(
                p.dirX + (noseX - 0.5) * p.sshiftX,
                p.dirY + (noseY - 0.5) * -p.sshiftY,
                500
            );

            const dX = (noseX - 0.5) * p.distortion;
            const dY = (noseY - 0.5) * (p.distortion * 0.75);
            
            const pos = this.screenPlaneGeometry.attributes.position;
            const halfW = this.width / 2;
            const halfH = this.height / 2;

            pos.setXY(0, -halfW + dX,  halfH + dY);
            pos.setXY(1,  halfW + dX,  halfH + dY);
            pos.setXY(2, -halfW + dX, -halfH + dY);
            pos.setXY(3,  halfW + dX, -halfH + dY);
            pos.needsUpdate = true;
        }

        render() {
            this.renderer.setClearColor(0x000000, 0);
            this.renderer.setRenderTarget(this.renderTarget);
            this.renderer.render(this.charScene, this.charCamera);
            this.renderer.setRenderTarget(null);
            this.renderer.render(this.postScene, this.postCamera);
        }

        onWindowResize() {
            this.width = window.innerWidth;
            this.height = window.innerHeight;
            this.charCamera.aspect = this.width / this.height;
            this.charCamera.updateProjectionMatrix();
            
            this.postCamera.left = -this.width / 2;
            this.postCamera.right = this.width / 2;
            this.postCamera.top = this.height / 2;
            this.postCamera.bottom = -this.height / 2;
            this.postCamera.updateProjectionMatrix();

            this.renderer.setSize(this.width, this.height);
            this.renderTarget.setSize(this.width, this.height);
            
            this.screenPlaneGeometry.dispose();
            this.screenPlaneGeometry = new THREE.PlaneGeometry(this.width, this.height, 1, 1);
            this.postScene.children[0].geometry = this.screenPlaneGeometry;
        }
    }

    // ==========================================
    // 3. Model Manager (Fixed Jitter & Material)
    // ==========================================
    class ModelManager {
        constructor(scene) {
            this.scene = scene;
            this.currentModel = null;
            this.neckBone = null;
            this.loader = new FBXLoader();
            
            // 修正1：計算の基準となる初期サイズ情報を保持する変数
            this.baseSize = new THREE.Vector3();
            this.baseCenter = new THREE.Vector3();
            this.baseScale = 1;
        }

        loadModel(buffer) {
            if (this.currentModel) this.scene.remove(this.currentModel);
            
            const object = this.loader.parse(buffer);
            this.neckBone = null;

            object.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    // 修正2：マテリアルをマット（つや消し）にする
                    if (child.material) {
                        const mats = Array.isArray(child.material) ? child.material : [child.material];
                        mats.forEach(m => {
                            m.shadowSide = THREE.DoubleSide;
                            
                            // テカリを抑える設定
                            m.roughness = 1.0; // 粗さを最大に（光沢なし）
                            m.metalness = 0.0; // 金属感をゼロに
                            m.shininess = 0;   // PhongMaterial用
                            m.specular = new THREE.Color(0x000000); // 反射光を黒（なし）に
                            
                            m.needsUpdate = true;
                        });
                    }
                }
                if (child.isBone) {
                    const name = child.name.toLowerCase();
                    if (name.includes("neck") || name.includes("head")) {
                        this.neckBone = child;
                    }
                }
            });

            this.currentModel = object;

            // 修正1の続き：モデルの初期状態のサイズと中心を計算して保存
            // まずスケールをリセットして純粋なサイズを測る
            this.currentModel.scale.set(1, 1, 1);
            this.currentModel.position.set(0, 0, 0);
            this.currentModel.rotation.set(0, 0, 0);
            this.currentModel.updateMatrixWorld(true);

            const box = new THREE.Box3().setFromObject(this.currentModel);
            box.getSize(this.baseSize); // 元のサイズ
            box.getCenter(this.baseCenter); // 元の中心座標
            this.baseScale = this.currentModel.scale.x; // 通常は1

            this.updateTransform(); // ユーザー設定を反映
            this.scene.add(object);
            
            const status = document.getElementById("status");
            status.innerText = "モデル読込完了";
            status.style.color = "#00fff2";
        }

        updateTransform() {
            if (!this.currentModel) return;
            const p = state.params;

            // 修正1の続き：
            // 毎回Box3を計算するのではなく、初期値(baseSize)を使って計算する
            // これにより、計算結果がループして震える現象を防ぐ
            
            // 最大寸法を計算
            const maxDim = Math.max(this.baseSize.x, this.baseSize.y, this.baseSize.z);
            
            // ターゲットスケールの計算 (任意の係数 / 元のサイズ)
            const targetScale = p.scale / maxDim;
            this.currentModel.scale.setScalar(targetScale);

            // 位置合わせ
            // (元の中心 * スケール) 分だけずらして、原点に合わせる + ユーザー指定のオフセット
            this.currentModel.position.set(
                -(this.baseCenter.x * targetScale) + p.posX,
                -(boxYMin(this.currentModel) * targetScale) + p.posY, // 足元合わせ簡易計算
                -40
            );

            // ※足元の正確な位置合わせのため、簡易ヘルパー関数を利用
            function boxYMin(obj) {
                // ここだけは簡易Box計算してもスケール依存しないのでOKだが、
                // 厳密には baseCenter.y - baseSize.y/2 を使うのが一番ブレない
                return 0; // 多くのモデルは原点が足元にあるため0と仮定。
                // モデルの原点が中心にある場合などは微調整が必要ですが、
                // 今回は「ガクガク」防止優先のため、ユーザー入力のposYで調整してもらう設計にします。
            }
            
            // より厳密なY合わせ（BaseBoxを使う場合）
            const boxBottomY = this.baseCenter.y - (this.baseSize.y / 2);
            this.currentModel.position.y = -(boxBottomY * targetScale) + p.posY;
        }

        updateHeadRotation(noseX, noseY) {
            if (!this.neckBone) return;
            const p = state.params;
            const targetRotY = -(noseX - 0.5) * p.neckRot;
            const targetRotX = (noseY - 0.5) * (p.neckRot * 0.6);
            
            this.neckBone.rotation.y += (targetRotY - this.neckBone.rotation.y) * 0.1;
            this.neckBone.rotation.x += (targetRotX - this.neckBone.rotation.x) * 0.1;
        }
    }

    // ==========================================
    // 4. Face Tracker
    // ==========================================
    class FaceTracker {
        constructor(videoElement, onLandmarks) {
            this.video = videoElement;
            this.onLandmarks = onLandmarks;
            this.faceLandmarker = null;
            this.lastVideoTime = -1;
        }
        async init() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
            this.faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { 
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`, 
                    delegate: "GPU" 
                },
                runningMode: "VIDEO"
            });
            this.startWebcam();
        }
        async startWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                this.video.srcObject = stream;
            } catch (err) {
                console.error(err);
                document.getElementById("status").innerText = "カメラエラー";
            }
        }
        detect() {
            if (!this.faceLandmarker || !this.video.videoWidth) return;
            if (this.lastVideoTime !== this.video.currentTime) {
                const result = this.faceLandmarker.detectForVideo(this.video, performance.now());
                if (result.faceLandmarks && result.faceLandmarks.length > 0) {
                    this.onLandmarks(result.faceLandmarks[0]);
                }
                this.lastVideoTime = this.video.currentTime;
            }
        }
    }

    // ==========================================
    // 5. UI Manager
    // ==========================================
    class UIManager {
        constructor() {
            this.initInputs();
            this.initFileUpload();
        }
        initInputs() {
            document.querySelectorAll('input[type="range"]').forEach(input => {
                const paramName = input.id.replace('p-', '');
                input.value = state.get(paramName);
                this.updateLabel(paramName, input.value);
                input.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    state.set(paramName, val);
                    this.updateLabel(paramName, val);
                });
            });
        }
        updateLabel(paramName, value) {
            const label = document.querySelector(`[data-bind="${paramName}"]`);
            if (label) label.innerText = value;
        }
        initFileUpload() {
            const fileInput = document.getElementById('file-input');
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => app.modelManager.loadModel(evt.target.result);
                reader.readAsArrayBuffer(file);
            });
        }
    }

    // ==========================================
    // Main App
    // ==========================================
    class App {
        constructor() {
            this.sceneManager = new SceneManager('three-canvas-container');
            this.modelManager = new ModelManager(this.sceneManager.charScene);
            this.uiManager = new UIManager();
            this.faceTracker = new FaceTracker(
                document.getElementById("webcam"),
                (landmarks) => this.onFaceDetected(landmarks)
            );
            
            state.subscribe((key) => {
                if (['scale', 'posX', 'posY'].includes(key)) {
                    this.modelManager.updateTransform();
                }
            });

            this.faceTracker.init().then(() => {
                document.getElementById("status").innerText = "トラッキング中";
                this.animate();
            });
        }
        onFaceDetected(landmarks) {
            const nose = landmarks[1];
            this.sceneManager.updateCameraAndShadows(nose.x, nose.y);
            this.modelManager.updateHeadRotation(nose.x, nose.y);
        }
        animate() {
            this.faceTracker.detect();
            this.sceneManager.render();
            requestAnimationFrame(() => this.animate());
        }
    }

    const app = new App();
</script>
</body>
</html>